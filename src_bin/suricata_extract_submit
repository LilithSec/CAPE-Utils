#!/usr/bin/env perl

=head1 NAME

suricata_extract_submit - Submits files to mojo_cape_submit for detonation via CAPEv2

=head1 SYNOPSIS

suricata_extract_submit

*/5 * * * * /usr/local/bin/suricata_extract_submit 2> /dev/null > /dev/null

=head1 DESCRIPTION

This requires having the file-store output configured akin to below.

      - file-store:
          version: 2
          enabled: yes
          dir: /var/log/suricata/files
          write-fileinfo: yes
          stream-depth: 0
          force-hash: [sha1, md5]
          xff:
            enabled: no
            mode: extra-data
            deployment: reverse
            header: X-Forwarded-For

=head1 CONFIGURATION

The config file used is '/usr/local/etc/suricata_extract_submit.ini'.

    # the API key to use if needed
    #apikey=
    # URL to find mojo_cape_submit at
    url=http://192.168.14.15:8080/
    # the group/client/whathaveya slug
    slug=foo
    # where Suricata has the file store at
    filestore=/var/log/suricata/files
    # a file of IPs or subnets to ignore SRC or DEST IPs of
    #ignore=
    # a file of regex to use for checking host names go ignore
    #ignoreHosts=

=cut

use File::Find::Rule;
use warnings;
use strict;
use Config::Tiny;
use File::Slurp;
use Time::Piece;
use File::MimeInfo::Magic;
use Crypt::Digest::MD5 qw( md5 md5_hex md5_b64 md5_b64u
	md5_file md5_file_hex md5_file_b64 md5_file_b64u );
use Crypt::Digest::SHA256 qw( sha256 sha256_hex sha256_b64 sha256_b64u
	sha256_file sha256_file_hex sha256_file_b64 sha256_file_b64u );
use Crypt::Digest::SHA1 qw( sha1 sha1_hex sha1_b64 sha1_b64u
	sha1_file sha1_file_hex sha1_file_b64 sha1_file_b64u );
use Net::Subnet qw(subnet_matcher);
use LWP::UserAgent;
use HTTP::Request::Common;
use File::Temp qw/ tempdir  /;
use File::Copy;
use POSIX 'strftime';
use Sys::Syslog;
use JSON;
use Sys::Hostname;

# sends stuff to syslog
sub log_something {
	my ( $level, $message ) = @_;

	if ( !defined($level) ) {
		$level = 'info';
	}

	openlog( 'suricata_extract_submit', 'cons,pid', 'daemon' );
	syslog( $level, '%s', $message );
	closelog();

	print $message. "\n";
}

log_something( 'info', 'Suricata Malware Extractor starting up..' );

# sensor config file
my $config_file = '/usr/local/etc/suricata_extract_submit.ini';
my $config      = Config::Tiny->read($config_file);
log_something( 'info', 'Config ' . $config_file . ' read...' );

# information for submitting it...
my $apikey = $config->{_}->{apikey};
if ( !defined($apikey) ) {
	$apikey = '';
}
my $url = $config->{_}->{url};
if ( !defined($url) ) {
	my $message = 'No malware detonator specified via the setting url';
	log_something( 'err', $message );
}

# get the file store dir
my $filestore = $config->{_}->{filestore};
if ( !defined($filestore) ) {
	$filestore = '/var/log/suricata/files/';
}

# get the stats file
my $stats_file = $config->{_}->{filestore};
if ( !defined($stats_file) ) {
	$stats_file = '/var/cache/suricata_extract_submit_stats.json';
}
my $stats_default = {
	sub            => 0,
	sub_delta      => 0,
	sub_fail       => 0,
	sub_fail_delta => 0,
	zero_sized     => 0,
	zero_delta     => 0,
	sub_2xx        => 0,
	sub_2xx_delta  => 0,
	sub_3xx        => 0,
	sub_3xx_delta  => 0,
	sub_4xx        => 0,
	sub_4xx_delta  => 0,
	sub_5xx        => 0,
	sub_5xx_delta  => 0,
	last_errors    => [],
	errors         => 0,
	errors_delta   => 0,
};
my $stats;
if ( -f $stats_file && -r $stats_file ) {
	eval { $stats = decode_json(read_file); };
	if ($@) {
		log_something( 'err',
			'stats file, "' . $stats_file . '", reading or parsing failed, using default stats... ' . $@ );
		$stats = $stats_default;
	}

}

# if it exists, but is not readable, error and use the default
elsif ( -f $stats_file && !-r $stats_file ) {
	my $error = 'stats file, "' . $stats_file . '", exists, but is not readable, using default stats';
	log_something( 'err', $error );
	$stats = $stats_default;
	$stats->{errors}++;
	push( @{ $stats->{last_errors} }, $error );
}
else {
	$stats = $stats_default;
}
my $new_stats = $stats;

# read in the file of IPs to ignore
my $ignore_file = $config->{_}->{ignore};
my @to_ignore;
if ( defined($ignore_file) && -f $ignore_file ) {
	log_something( 'info', 'reading in ignore file... ' . $ignore_file );
	my $ignore_raw = read_file($ignore_file);

	my @to_ignore_raw = split( /\n/, $ignore_raw );
	@to_ignore_raw = grep( !/^\w*\#/, @to_ignore_raw );
	@to_ignore_raw = grep( !/^\w*$/,  @to_ignore_raw );

	# process the @to_ignore_raw adding subnets if needed
	my $ignored = 0;
	foreach my $item (@to_ignore_raw) {

		# remove any white space at the start or end
		$item =~ s/^[\ \t]+//;
		$item =~ s/[\ \t]+$//;
		if ( $item =~ /^[0-9\.]+$/ ) {
			$item = $item . '/32';
		}
		if ( $item =~ /^[0-9\:]+$/ ) {
			$item = $item . '/128';
		}
		push( @to_ignore, $item );

		$ignored++;
	}

	log_something( 'info', 'ignoring ' . $ignored . ' subnets or IPs' );
}
my $ip_ignore = subnet_matcher @to_ignore;

# read in the file of IPs to ignore
my $ignoreHosts_file = $config->{_}->{ignoreHosts};
my @hosts_to_ignore;
if ( defined($ignoreHosts_file) && -f $ignoreHosts_file ) {
	log_something( 'info', 'reading in ignoreHosts file... ' . $ignoreHosts_file );
	my $ignoreHosts_raw = read_file($ignoreHosts_file);

	@hosts_to_ignore = split( /\n/, $ignoreHosts_raw );
	@hosts_to_ignore = grep( !/^\w*\#/, @hosts_to_ignore );
	@hosts_to_ignore = grep( !/^\w*$/,  @hosts_to_ignore );

	my $found_regex = $#hosts_to_ignore;
	log_something( 'info', $found_regex . ' regexs loaded to ignore for hosts' );
}

# create a tmpdir and chdir to it
my $tempdir = tempdir();
chdir($tempdir);

# find any json files
log_something( 'info', 'Looking for JSON files under ' . $filestore );
my @files = File::Find::Rule->file()->name("*json")->in($filestore);

# exit if we don't find anything as there is no point to continue
if ( !defined( $files[0] ) ) {
	log_something( 'info', 'None found at this time' );
	exit 0;
}

# process any found
foreach my $file (@files) {
	print "\n";

	log_something( 'info', "Processing... " . $file );
	my $name;
	eval {
		my $file_raw = read_file($file);
		log_something( 'info', 'Raw JSON... ' . $file_raw );

		my $file_json = decode_json($file_raw);
		my $data_file = $file;
		$data_file =~ s/\.[0-9\.]+\.json$//;
		log_something( 'info', 'Sample File: ' . $data_file );

		my $data      = read_file($data_file);
		my $data_size = length($data);
		log_something( 'info', 'Sample Size: ' . $data_size );

		# get the timestramp and transform it into for getting the epoch
		my $timestamp = $file_json->{timestamp};
		$timestamp =~ s/\..*$//;
		my $t = Time::Piece->strptime( $timestamp, '%Y-%m-%dT%H:%M:%S' );

		my $filename = $file_json->{fileinfo}{filename};

		my $md5    = lc( md5_hex($data) );
		my $sha1   = lc( sha1_hex($data) );
		my $sha256 = lc( sha256_hex($data) );
		my $extUID = lc( substr( $md5, 0, 18 ) );

		my $mime = mimetype($filename);
		if ( !defined($mime) ) {
			$mime = 'application_x-ms-dos-executable';
		}
		else {
			$mime =~ s/\//\_/g;
		}
		log_something( 'info', 'MIME type: ' . $mime );

		my $add_it = 1;
		if ( $ip_ignore->( $file_json->{src_ip} ) ) {
			log_something( 'info', 'Ignore Listed Source IP: ' . $file_json->{src_ip} );
			$add_it = 0;
		}
		if ( $ip_ignore->( $file_json->{dest_ip} ) ) {
			log_something( 'info', 'Ignore Listed Destination IP: ' . $file_json->{src_ip} );
			$add_it = 0;
		}
		foreach my $item (@hosts_to_ignore) {
			if ( defined( $file_json->{http} ) && defined( $file_json->{http}{hostname} ) ) {
				if ( $file_json->{http}{hostname} =~ /$item/ ) {
					log_something( 'info', 'Ignore Listed Host, "' . $item . '": ' . $file_json->{http}{hostname} );
					$add_it = 0;
				}
			}
		}

		$name
			= $file_json->{src_ip} . '-'
			. $file_json->{src_port} . '-'
			. $file_json->{dest_ip} . '-'
			. $file_json->{dest_port} . '-'
			. $file_json->{proto} . '-'
			. $extUID . '-'
			. $config->{_}->{slug} . '-'
			. $t->epoch . '-'
			. $mime;

		# only add it if it is not white listed
		if ($add_it) {
			log_something( 'info', 'Name: ' . $name );

			# skip uploading it if it is zero sized
			if ( $data_size > 0 ) {

				# don't need to copy it if it is zero sized
				copy( $data_file, $name )
					or die 'Copy failed(' . $data_file . ' -> ' . $tempdir . '/' . $name . '): ' . $!;

				$file_json->{suricata_extract_submit} = {
					filename => $name,
					apikey   => $apikey,
					host     => hostname,
					to       => $config->{_}->{url},
					time     => time,
					md5      => $md5,
					sha256   => $sha256,
					sha1     => $sha1,
				};
				my $res;
				eval {
					my $ua = LWP::UserAgent->new(
						ssl_opts => { verify_hostname => 0, SSL_verify_mode => 0 },
						timeout  => 30
					);
					$res = $ua->request(
						POST $config->{_}->{url},
						Content_type => 'multipart/form-data',
						Content      => [
							apikey   => $apikey,
							filename => [$name],
							type     => 'suricata_extract',
							json     => encode_json($file_json),
						],
					);
				};

				# save error status for later
				my $sub_error = $@;

				# see if we can get a status line
				my $status_line;
				if ( defined($res) ) {
					eval { $status_line = $res->status_line; };

					# compute that status line stats
					if ( defined($status_line) ) {
						if ( $status_line =~ /^2\d\d/ ) {
							$stats->{sub_2xx}++;
						}
						elsif ( $status_line =~ /^3\d\d/ ) {
							$stats->{sub_3xx}++;
						}
						elsif ( $status_line =~ /^4\d\d/ ) {
							$stats->{sub_4xx}++;
						}
						elsif ( $status_line =~ /^5\d\d/ ) {
							$stats->{sub_5xx}++;
						}
					}
				}

				# handle submission errors
				if ($sub_error) {
					$stats->{sub_fail}++;

					# if this is defined, submission worked, but we got a sub error
					if ( defined($status_line) ) {
						my $error = "Failed to post... " . $res->status_line;
						push( @{ $stats->{last_errors} }, $error );
						die($error);
					}

					# if we don't have a status line the submission eval never got that far
					else {
						$stats->{errors}++;
						my $error = "Failed to post... " . $sub_error;
						push( @{ $stats->{last_errors} }, $error );
						die($error);
					}
				}
				else {
					if ( $status_line =~ /^2\d\d/ ) {
						$stats->{sub}++;
						log_something( 'info', 'Uplodated Response Status: ' . $res->status_line );
					}
					else {
						$stats->{sub_fail}++;
						my $error = "Failed to post... " . $res->status_line;
						push( @{ $stats->{last_errors} }, $error );
						die($error);
					}
				}
			}
			else {
				$stats->{zero_sized}++;
				log_something( 'info', 'Not uploading as the sample is zero sized' );
			}
		}

		# rename the JSON file so we don't process it again
		move( $file, $file . '-processed' ) or die 'Appending "-processed" to the name of the JSON failed...' . $!;
		if ($@) {
			my $error = 'Failed to rename ' . $file . ' ... ' . $@;
			$stats->{errors}++;
			push( @{ $stats->{last_errors} }, $error );
			log_something( 'err', $error );
		}
	};
	if ($@) {
		log_something( 'err', 'Processing failed... ' . $@ );
	}

	# only unlink the file if it exists... otherwise the copy failed
	if ( -f $name ) {

		# now that we are done with the tmp file, we can remove it
		unlink($name);
	}
}
